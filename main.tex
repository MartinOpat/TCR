\documentclass[
	a4paper,
	landscape,
	%twoside,
	10pt,
]{article}

% DO NOT REMOVE
\input{sources/packages.tex}
\input{sources/customFunctions.tex}
\input{sources/customEnviroments.tex}

% Fill out
\newcommand{\mytitle}{~}
\newcommand{\myauthor}{Martin Opat}
\newcommand{\mycoursename}{TCR}


%*************** Table of Contents ***************
\usepackage[toc]{multitoc}			% multicolumn toc
\usepackage{tocloft}				% to reduce toc spacing
\renewcommand*{\multicolumntoc}{3}
% reduce section spacing in toc
\setlength{\cftbeforesecskip}{-1pt}
\setlength{\cftbeforesubsecskip}{-1.5pt}
% remove the toc title
\makeatletter
\renewcommand{\@cftmaketoctitle}{}
\makeatother

\begin{document}
\setcounter{tocdepth}{3}
\tableofcontents

\begin{multicols}{3}
\section{Setup}
\otherentry{header.h}{~}{code/header.h}
\otherentry{Bash for c++ compile with header.h}{~}{compile_c++.sh}
\otherentry{Bash for run tests c++}{~}{code/test_cpp.sh}
\otherentry{Bash for run tests python}{~}{code/test_py.sh}
\entry{Aux. helper C++}{~}{code/auxiliary.cpp}
\pyentry{Aux. helper python}{~}{code/auxiliary.py}

\section{Python}
\subsection{Graphs}
	\pyentry{BFS}{~}{code/Graphs/bfs.py}
	\pyentry{Dijkstra}{~}{code/Graphs/dijkstra_filtered.py}
	\pyentry{Topological Sort}{~}{code/Graphs/topological_sort.py}
	\pyentry{Kruskal (UnionFind)}{~}{code/Graphs/kruskal_new.py}

\subsection{Num. Th. / Comb.}
	\pyentry{nCk \% prime}{~}{code/Number Theory/nCk_mod_prime.py}
	\pyentry{Sieve of E.}{$O(n)$ so actually faster than C++ version, but more memory}{code/Number Theory/better_sieve.py}

\subsection{Strings}
	\pyentry{LCS}{~}{code/Strings/lcs.py}
	\pyentry{KMP}{~}{code/Strings/kmp.py}
	\pyentry{Edit distance}{~}{code/Strings/edit_distance.py}

\subsection{Other Algorithms}
	\pyentry{Rotate matrix}{~}{code/Other/rotate_matrix.py}

\subsection{Geometry}
	\pyentry{Convex Hull}{~}{code/Geometry/convexhull.py}
	\pyentry{Geometry}{~}{code/Geometry/geometry.py}

\subsection{Other Data Structures}
	\pyentry{Segment Tree}{~}{code/Data Structures/segment_tree.py}
	\pyentry{Trie}{~}{code/Data Structures/trie.py}



\section{C++}
\subsection{Graphs}
    \entry{BFS}{~}{code/Graphs/bfs_filtered.cpp}
	\entry{DFS}{Cycle detection / removal}{code/Graphs/dfs.cpp}
	\entry{Dijkstra}{~}{code/Graphs/dijkstra_filtered.cpp}
	\entry{Floyd-Warshall}{~}{code/Graphs/warshall.cpp}
	\entry{Kruskal}{Minimum spanning tree of undirected weighted graph}{code/Graphs/kruskal.cpp}
	\entry{Hungarian algorithm}{~}{code/Graphs/hungarian.cpp}
	\entry{Suc. shortest path}{Calculates max flow, min cost}{code/Graphs/succ_shortest_path.cpp}
	\entry{Bipartite check}{~}{code/Graphs/bipartite_check.cpp}
	\entry{Find cycle directed}{~}{code/Graphs/find_cycle_directed.cpp}
	\entry{Find cycle directed}{~}{code/Graphs/find_cycle_undirected.cpp}
	\entry{Tarjan's SCC}{~}{code/Graphs/tarjan.cpp}
	\entry{SCC edges}{Prints out the missing edges to make the input digraph strongly connected}{code/Graphs/scc_edges.cpp}   % TODO: Possibly try to find a better algorithm
	\entry{Find Bridges}{~}{code/Graphs/find_bridges.cpp}
	\entry{Artic. points}{(i.e. cut off points)}{code/Graphs/find_articulation_points.cpp}
	\entry{Topological sort}{~}{code/Graphs/topo_sort.cpp}
	\entry{Bellmann-Ford}{Same as Dijkstra but allows neg. edges}{code/Graphs/bellmannford.cpp}
	\entry{Ford-Fulkerson}{Basic Max. flow}{code/Graphs/ford-fulk.cpp}
	\entry{Dinic max flow}{$O(V^2E)$, $O(Ef)$}{code/Graphs/dinic.cpp}

\subsection{Dynamic Programming}
	\entry{Longest Incr. Subseq.}{~}{code/Dynamic Programming/lis.cpp}
	\entry{0-1 Knapsack}{~}{code/Dynamic Programming/0-1_knapsack.cpp}
	\entry{Coin change}{Number of coins required to achieve a given value}{code/Dynamic Programming/coin_change.cpp}

\subsection{Trees}
	\entry{Tree diameter}{~}{code/Graphs/tree_diameter.cpp}
	\entry{Tree Node Count}{~}{code/Graphs/tree_node_count.cpp}

\subsection{Num. Th. / Comb.}
	\entry{Basic stuff}{~}{code/Number Theory/elementary.cpp}
	\entry{Mod. exponentiation}{Or use pow() in python}{code/Number Theory/mod_exp.cpp}
	\entry{GCD}{Or math.gcd in python, std::gcd in C++}{code/Number Theory/gcd.cpp}
	\entry{Sieve of Eratosthenes}{~}{code/Number Theory/sieve.cpp}
	\entry{Fibonacci \% prime}{~}{code/Number Theory/fib_mod_prime.cpp}
	\entry{nCk \% prime}{~}{code/Number Theory/nCk_mod_prime.cpp}
	\entry{Chin. rem. th.}{~}{code/Number Theory/chinese_rt.cpp}

\subsection{Strings}
	\entry{Z alg.}{KMP alternative}{code/Strings/z.cpp}
	\entry{KMP}{~}{code/Strings/kmp.cpp}
	\entry{Aho-Corasick}{Also can be used as Knuth-Morris-Pratt algorithm}{code/Strings/aho_corasick.cpp}
	\entry{Long. palin. subs}{Manacher - $O(n)$}{code/Strings/manacher.cpp}

\subsection{Geometry}
	\entry{essentials.cpp}{~}{code/Geometry/essentials.cpp}
	\entry{Two segs. itersec.}{~}{code/Geometry/intersec.cpp}
	\entry{Convex Hull}{~}{code/Geometry/convex_hull.cpp}

\subsection{Other Algorithms}
	\entry{2-sat}{~}{code/Combinatorics/2-sat.cpp}
	\entry{Matrix Solve}{~}{code/Other/matrix_solve.cpp}
	\entry{Matrix Exp.}{~}{code/Other/matrix_exp.cpp}
	\entry{Finite field}{For FFT}{code/Other/fin_field.cpp}
	\entry{Complex field}{For FFR}{code/Other/complex_field.cpp}
	\entry{FFT}{~}{code/Other/fft.cpp}
	\entry{Polyn. inv. div.}{~}{code/Other/poly.cpp}
	\entry{Linear recurs.}{Given a linear recurrence of the form
	$$a_n = \sum_{i=0}^{k-1} c_i a_{n-i-1}$$
	this code computes $a_n$ in $O(k \log k \log n)$ time.}{code/Other/lin_recursion.cpp}
	\entry{Convolution}{Precise up to 9e15}{code/Other/convo.cpp}
	\entry{Partitions of $n$}{Finds all possible partitions of a number}{code/Other/all_partitions.cpp}

\subsection{Other Data Structures}
	\entry{Disjoint set}{(i.e. union-find)}{code/Data Structures/disjoint_set.cpp}
	\entry{Fenwick tree}{(i.e. BIT) eff. update + prefix sum calc.}{code/Data Structures/fenwick_tree.cpp}
	\entry{Fenwick2d tree}{~}{code/Data Structures/fenwick2d.cpp}
	\entry{Trie}{~}{code/Data Structures/trie.cpp}
	\entry{Treap}{A binary tree whose nodes contain two values, a key and a priority, such that the key keeps the BST property}{code/Data Structures/treap.cpp}

\section{Other Mathematics}
	\subsection{Helpful functions}
		\entry{Euler's Totient Fucntion}
		{
			$n = p_1^{k_1-1}\cdot(p_1-1) \cdot \hdots \cdot p_r^{k_r-1}\cdot(p_r-1)$, where $p_1^{k_1} \cdot \hdots \cdot p_r^{k_r}$ is the prime factorization of $n$.
		}
		{code/Other Math/euler_totient_func.cpp}
		\subsubsection*{Formulas}
			$\Phi(n)$ counts all numbers in ${1,\hdots,n-1}$ coprime to $n$. \\
			$a^{\varphi (n)} \equiv 1 \mod n$, $a$ and $n$ are coprimes. \\
			$\forall e > \log_2 m:~ n^e \mod m = n^{\Phi(m) + e \mod \Phi(m)} \mod m$. \\
			$\text{gcd}(m,n) = 1 \Rightarrow \Phi(m\cdot n) = \Phi(m) \cdot \Phi(n)$. \\

		\entry{Pascal's trinagle}{$\binom{n}{k}$ is $k$-th element in the $n$-th row, indexing both from 0}{code/Other Math/pascal_triangle.cpp}

	\newpage
	\subsection{Theorems and definitions}
		\subsubsection*{Fermat's little theorem}
		$$a^p \equiv a \mod p$$
		\subsubsection*{Subfactorial}
		$$!n = n! \sum_{i=0}^{n} \frac{(-1)^i}{i!}$$
		$$!(0) = 1, ~ !n = n \cdot !(n-1) + (-1)^n$$

		\subsubsection*{Binomials and other partitionings}
		$$\binom{n}{k} = \binom{n-1}{k}+\binom{n-1}{k-1} =
			\prod_{i=1}^k \frac{n-i+1}{i}$$ This last product may be computed
		incrementally since any product of $k'$ consecutive values is divisibleby
		$k'!$. \\
		Basic identities: The hockeystick identity: \\
		 $$\sum_{k=r}^n \binom{k}{r}
			= \binom{n+1}{r+1}$$
		or $$\sum_{k\leq n}\binom{r+k}{k} = \binom{r+n+1}{n}$$
		Also $$\sum_{k=0}^n \binom{k}{m} = \binom{n+1}{m+1}$$
		$$\sum_{i=0}^{n} \binom{n}{i} = 2^n$$

		For $n, m \geq 0$ and $p$ prime: write $n, m$ in base $p$, i.e.
		$n = n_k p^k + \dots + n_1 p + n_0$ and $m = m_k p^k + \dots m_1 p + m_0$. Then
		by Lucas theorem we have $\binom{n}{m} \equiv \prod_{i=0}^k \binom{n_i}{m_i}
		\mod p$, with the convention that $n_i < m_i \implies \binom{n_i}{m_i} =0$.

		\subsubsection*{Fibonacci} (See also number theory section) \\
 		$$\sum_{0 \leq k \leq n} \binom{n-k}{k} = F_{n+1}$$ 
		$$F_n = \frac{1}{\sqrt{5}} \left(\frac{1+\sqrt{5}}{2}\right)^n - \frac{1}{\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n$$
		$\sum_{i=1}^{n} {F_i} = F_{n+2}-1$, $\sum_{i=1}^{n} {F_i^2} = F_{n}F_{n+1}$
		$$\text{gcd}(F_m, F_n) = F_{\text{gcd}(m, n)}$$
		$$\text{gcd}(F_n, F_{n+1}) = \text{gcd}(F_n, F_{n+2}) = 1$$

		\subsubsection*{Bit stuff} $a + b = a \oplus b + 2(a\&b) = a | b + a\&b$. \\
		kth bit is set in $x$ iff $x \mod 2^{k-1} \geq 2^k$, or iff $x \mod 2^{k-1}  - x \mod 2^k \neq 0~(\text{i.e.} = 2^k)$ It comes handy when you need to look at the bits of the numbers which are pair sums or subset sums etc. \\
		$n \mod 2^i = n\&(2^i-1)$. \\
		$\forall k:~ 1 \oplus 2 \oplus \hdots \oplus (4k-1) = 0$

		\subsubsection*{Stirling's numbers} \textbf{First kind:} $S_1(n, k)$ count permutations on $n$ items
		with $k$ cycles. $S_1(n, k) = S_1(n-1, k-1) + (n-1)S_1(n-1, k)$ with
		$S_1(0, 0) = 1$. Note:
		$$\sum_{k=0}^n S_1(n, k)x^k = x(x+1)\dots(x+n-1)$$
		$$ \sum_{k=0}^n S_1(n, k) = n! $$
		\textbf{Second kind:} $S_2(n, k)$ count partitions of $n$
		distinct elements into exactly $k$ non-empty groups.
		$$ S_2(n, k) = S_2(n-1, k-1) + kS_2(n-1, k)$$
		$$S_2(n, 1) = S_2(n, n) = 1$$
		$$ S_2(n, k) = \frac{1}{k!}\sum_{i=0}^k (-1)^{k-i}\binom{k}{i}i^n $$

		\subsection{Geometry Formulas}
		\begin{gather*}
			[ABC]
			= rs
			= \frac 12 ab\sin\gamma \\
			= \frac{abc}{4R}
			= \sqrt{s(s-a)(s-b)(s-c)}
			= \frac 12\left| (B-A, C-A)^T \right|
		\end{gather*}

		\begin{align*}
			s &= \frac {a+b+c}2 & 2R &=\frac{a}{\sin \alpha}\\
			\textrm{cosine rule:}&&  c^2 &= a^2 + b^2 - 2ab\cos \gamma\\
			\textrm{Euler:}&&  1 + CC &= V - E + F\\
            \textrm{Pick:}&& \textrm{Area} &= {\small \textrm{itr pts}
            + \frac{\textrm{bdry pts}}2 - 1}\\
			p\cdot q &= |p||q|\cos(\theta) & |p\times q| &= |p||q|\sin(\theta)\\
		\end{align*}

		Given a non-self-intersecting closed polygon on $n$ vertices, given as $(x_i, y_i)$, its centroid $(C_x, C_y)$ is given as:

		\begin{align*}
			C_x &= \frac{1}{6A} \sum_{i = 0}^{n - 1} (x_i + x_{i+1}) (x_i y_{i+1} - x_{i+1} y_i), \\
			C_y &= \frac{1}{6A} \sum_{i = 0}^{n - 1} (y_i + y_{i+1}) (x_i y_{i+1} - x_{i+1} y_i)
		\end{align*}

		\begin{equation*}
			A = \frac{1}{2} \sum_{i = 0}^{n - 1} (x_i y_{i+1} - x_{i+1} y_i) = \textrm{polygon area}
		\end{equation*}

		\subsubsection*{Inclusion-Exclusion}
		For appropriate $f$ compute $\sum_{S\subseteq T} (-1)^{|T\setminus S|} f(S)$,
		or if only the size of $S$ matters, $\sum_{s=0}^n (-1)^{n-s} \binom{n}{s}f(s)$.
		In some contexts we might use Stirling numbers, not binomial coefficients!

		Some useful applications:
		\begin{enumerate}
			\item[] \textbf{Graph coloring} Let $I(S)$ count the number
				of independent sets
				contained in $S \subseteq V$ ($I(\emptyset) = 1$,
				$I(S) = I(S\setminus v) + I(S\setminus N(v))$). Let
				$c_k = \sum_{S\subseteq V} (-1)^{|V\setminus S|} I(S)$. Then $V$
				is $k$-colorable iff $v > 0$. Thus we can compute the chromatic
				number of a graph in $O^*(2^n)$ time.
		\end{enumerate}

		\subsubsection*{Burnside's lemma}
		Given a group $G$ acting on a set $X$, the number of elements in $X$ up to
		symmetry is $$\frac{1}{|G|}\sum_{g\in G} |X^g|$$ with $X^g$ the elements of
		$X$ invariant under $g$. For example, if $f(n)$ counts ``configurations''
		of some sort of length $n$, and we want to count them up to rotational symmetry
		using $G = \mathbb{Z}/n\mathbb{Z}$, then

		$$g(n) = \frac{1}{n} \sum_{k=0}^{n-1} f(\gcd(n, k))
			= \frac{1}{n}\sum_{k \| n} f(k) \phi(n / k)$$

		I.e. for coloring with $c$ colors we have $f(k) = k^c$.

		Relatedly, in P\'olya's enumeration theorem we imagine $X$ as a set of $n$
		beads with $G$ permuting the beads (e.g. a necklace, with $G$ all rotations and
		reflections of the $n$-cycle, i.e. the dihedral group $D_n$).
		Suppose further that we had $Y$ colors, then
		the number of $G$-invariant colorings $Y^X / G$ is counted by

		$$\frac{1}{|G|}\sum_{g\in G} |Y|^{c(g)}$$

		with $c(g)$ counting the number of cycles of $g$ when viewed as a permutation
		of $X$. We can generalize this to a weighted version: if the color $i$ can
		occur exactly $r_i$ times, then this is counted by the coefficient of
		$t_1^{r_1}\dots t_n^{r_n}$ in the polynomial
		$$Z(t_1,\dots,t_n) = \frac{1}{|G|}\sum_{g\in G} \prod_{m\geq 1}
			(t_1^m+\dots+t_n^m)^{c_m(g)}$$
		where $c_m(g)$ counts the number of length $m$ cycles in $g$ acting as a
		permutation on $X$. Note we get the original formula by setting all $t_i=1$.
		Here $Z$ is the cycle index. Note: you can cleverly deal with even/odd sizes
		by setting some $t_i$ to $-1$.
		
		\subsubsection*{Lucas Theorem}
		If $p$ is prime, then:
		$$ \frac{p^a}{k} \equiv 0 (\mod p) $$
		Thus for non-negative integers $m = m_kp^k + \hdots + m_1 p + m_0$ and $n = n_k p^k + \hdots + n_1p + n_0$:
		$$ \frac{m}{n} =  \Pi_{i=0}^{k} \frac{m_i}{n_i} \mod p $$ Note: The fraction's mean integer division.
		

		\subsubsection*{Catalan Numbers} - Number of correct bracket sequence consisting of $n$ opening and $n$
		closing brackets. \\
		The number of ways to completely parenthesize $n+1$ factors. \\
		The number of triangulations of a convex polygon with $n+2$
		sides (i.e. the number of partitions of polygon into disjoint triangles by using the diagonals). \\
		The number of ways to connect the $2n$
		points on a circle to form n disjoint i.e. non-intersecting chords.
		$$ C_n = \frac{1}{n+1} \binom{2n}{n}$$
		$$ C_0 = 1,~C_1 = 1, ~C_n = \sum_{k=0}^{n-1}C_k C_{n-1-k}  $$

		\subsubsection*{Narayana numbers} The number of expressions containing n pairs of parentheses, which are correctly matched and which contain k distinct nestings. 
		$$ N(n,k) = \frac{1}{n} \frac{n}{k} \frac{n}{k-1} $$
\end{multicols}
\end{document}
